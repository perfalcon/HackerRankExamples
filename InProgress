static int[] climbingLeaderboard(int[] scores, int[] alice) {

        List tempList = new ArrayList();
        int[] result = new int[alice.length];
        for(int i=0;i<scores.length;i++){

            tempList.add(scores[i]);
        }
        
        System.out.println(tempList);
        //remove duplicates
        Set<Integer> set = new LinkedHashSet();
        set.addAll(tempList);
        tempList.clear();
        tempList.addAll(set);
        System.out.println(tempList);
        for(int i=0;i<alice.length;i++){
         int rank = Collections.binarySearch(tempList,alice[i],Collections.reverseOrder());
         System.out.println("Rank-->"+rank);
         if(rank > 0){
             rank++;
         }
         result[i]=Math.abs(rank);   
        }
        System.out.print("rank-->"+result);
        return result;


    }
===
worked solution
int results[] = new int[alice.length];
int rank = 1;
int rankScore = scores[0];

for (int a = alice.length - 1, s = 0; a >= 0; a--) {
	if (alice[a] < rankScore) {
		for (; s < scores.length; s++) {
			if (scores[s] < rankScore) {
				rank++;
				rankScore = scores[s];
			}				
			if(alice[a] >= scores[s]) break;
		}
	}

	results[a] = s == scores.length ? rank + 1 : rank;
}

return results;
